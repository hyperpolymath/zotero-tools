// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Int from "@rescript/runtime/lib/es6/Stdlib_Int.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

function requiredFields(itemType) {
  switch (itemType) {
    case "Book" :
      return [
        "title",
        "creators",
        "publisher",
        "date"
      ];
    case "BookSection" :
    case "JournalArticle" :
      return [
        "title",
        "creators",
        "publicationTitle",
        "date"
      ];
    case "Webpage" :
      return [
        "title",
        "url",
        "date"
      ];
    case "Manuscript" :
      return [
        "title",
        "creators"
      ];
    case "ConferencePaper" :
    case "Thesis" :
    case "Report" :
    case "Patent" :
      return [
        "title",
        "creators",
        "date"
      ];
  }
}

function hasField(citation, field) {
  switch (field) {
    case "creators" :
      return citation.creators.length !== 0;
    case "date" :
      return Stdlib_Option.isSome(citation.date);
    case "publicationTitle" :
      return Stdlib_Option.isSome(citation.publicationTitle);
    case "publisher" :
      return Stdlib_Option.isSome(citation.publisher);
    case "title" :
      return citation.title.length > 0;
    case "url" :
      return Stdlib_Option.isSome(citation.url);
    default:
      return false;
  }
}

function validateStructure(citation) {
  let issues = [];
  let required = requiredFields(citation.itemType);
  let missingFields = required.filter(field => !hasField(citation, field));
  let fieldIssues = missingFields.map(field => ({
    severity: "SeverityError",
    field: field,
    message: `Required field "` + field + `" is missing`,
    suggestion: `Add ` + field + ` to complete citation structure`,
    requiresUncertaintyNavigation: false
  }));
  let creatorIssues = citation.creators.length === 0 ? [{
        severity: "SeverityError",
        field: "creators",
        message: "Citation must have at least one creator",
        suggestion: "Add author, editor, or contributor",
        requiresUncertaintyNavigation: false
      }] : [];
  let titleIssues = citation.title.trim().length === 0 ? [{
        severity: "SeverityError",
        field: "title",
        message: "Title cannot be empty",
        suggestion: "Add a title for this citation",
        requiresUncertaintyNavigation: false
      }] : [];
  return issues.concat(fieldIssues).concat(creatorIssues).concat(titleIssues);
}

function isValidDateFormat(date) {
  let datePattern = /^\d{4}(-\d{2}(-\d{2})?)?$/;
  return datePattern.test(date);
}

function extractYear(date) {
  if (date.length >= 4) {
    return Stdlib_Int.fromString(date.substring(0, 4), undefined);
  }
}

function validateConsistency(citation) {
  let issues = [];
  let date = citation.date;
  let dateIssues;
  if (date !== undefined) {
    if (isValidDateFormat(date)) {
      let year = extractYear(date);
      dateIssues = year !== undefined ? (
          year < 1000 || year > 2100 ? [{
                severity: "SeverityWarning",
                field: "date",
                message: `Unusual publication year: ` + year.toString(),
                suggestion: "Verify publication date is correct",
                requiresUncertaintyNavigation: true
              }] : []
        ) : [];
    } else {
      dateIssues = [{
          severity: "SeverityError",
          field: "date",
          message: `Invalid date format: "` + date + `"`,
          suggestion: "Use ISO 8601 format (YYYY, YYYY-MM, or YYYY-MM-DD)",
          requiresUncertaintyNavigation: false
        }];
    }
  } else {
    dateIssues = [];
  }
  let creatorIssues = citation.creators.filter(c => c.lastName.trim().length === 0).map(param => ({
    severity: "SeverityError",
    field: "creators",
    message: "Creator missing lastName",
    suggestion: "Add lastName for all creators",
    requiresUncertaintyNavigation: false
  }));
  return issues.concat(dateIssues).concat(creatorIssues);
}

function isValidDOI(doi) {
  let doiPattern = /^10\.\d{4,}\/\S+$/;
  return doiPattern.test(doi);
}

function isValidISBN(isbn) {
  let clean = isbn.replace(/[-\s]/g, "");
  if (clean.length === 10) {
    return true;
  } else {
    return clean.length === 13;
  }
}

function validateReferences(citation) {
  let issues = [];
  let doi = citation.doi;
  let doiIssues = doi !== undefined ? (
      isValidDOI(doi) ? [] : [{
            severity: "SeverityWarning",
            field: "DOI",
            message: "DOI format may be invalid",
            suggestion: "DOI should start with \"10.\" followed by registrant/suffix",
            requiresUncertaintyNavigation: false
          }]
    ) : [];
  let isbn = citation.isbn;
  let isbnIssues = isbn !== undefined ? (
      isValidISBN(isbn) ? [] : [{
            severity: "SeverityWarning",
            field: "ISBN",
            message: "ISBN should be 10 or 13 digits",
            suggestion: "Verify ISBN is correct",
            requiresUncertaintyNavigation: false
          }]
    ) : [];
  let identifierIssues = Stdlib_Option.isNone(citation.doi) && Stdlib_Option.isNone(citation.isbn) && Stdlib_Option.isNone(citation.url) && citation.itemType !== "Manuscript" ? [{
        severity: "SeverityWarning",
        field: "identifiers",
        message: "No persistent identifier (DOI, ISBN, or URL)",
        suggestion: "Add DOI or ISBN if available",
        requiresUncertaintyNavigation: true
      }] : [];
  return issues.concat(doiIssues).concat(isbnIssues).concat(identifierIssues);
}

function determineState(issues) {
  let errors = issues.filter(i => i.severity === "SeverityError");
  let uncertainties = issues.filter(i => i.requiresUncertaintyNavigation);
  if (errors.length === 0) {
    if (uncertainties.length !== 0) {
      return "Uncertain";
    } else {
      return "Valid";
    }
  }
  let hasConsistencyErrors = errors.some(e => {
    if (e.message.includes("Invalid")) {
      return true;
    } else {
      return e.message.includes("inconsistent");
    }
  });
  if (hasConsistencyErrors) {
    return "Inconsistent";
  } else {
    return "Incomplete";
  }
}

function generateCertaintyReasoning(structural, consistency, referential, issues) {
  let structuralPart = structural >= 0.9 ? "Structurally complete" : (
      structural >= 0.7 ? "Mostly complete structure" : "Missing required fields"
    );
  let consistencyPart = consistency >= 0.9 ? "internally consistent" : (
      consistency >= 0.7 ? "minor inconsistencies" : "significant inconsistencies"
    );
  let referentialPart = referential >= 0.8 ? "strong referential integrity" : (
      referential >= 0.5 ? "some referential identifiers" : "weak referential integrity"
    );
  let uncertaintyCount = issues.filter(i => i.requiresUncertaintyNavigation).length;
  let uncertaintyPart = uncertaintyCount > 0 ? `, ` + uncertaintyCount.toString() + ` uncertainties require Fogbinder exploration` : "";
  return structuralPart + `, ` + consistencyPart + `, ` + referentialPart + uncertaintyPart + `.`;
}

function calculateCertainty(citation, issues) {
  let required = requiredFields(citation.itemType);
  let presentCount = required.filter(field => hasField(citation, field)).length;
  let structural = required.length !== 0 ? presentCount / required.length : 1.0;
  let errors = issues.filter(i => i.severity === "SeverityError");
  let totalChecks = issues.length + 10 | 0;
  let consistency = 1.0 - errors.length / totalChecks;
  let doiBoost = Stdlib_Option.isSome(citation.doi) ? 0.3 : 0.0;
  let isbnBoost = Stdlib_Option.isSome(citation.isbn) ? 0.2 : 0.0;
  let urlBoost = Stdlib_Option.isSome(citation.url) ? 0.1 : 0.0;
  let total = 0.5 + doiBoost + isbnBoost + urlBoost;
  let referential = total > 1.0 ? 1.0 : total;
  let score = structural * 0.5 + consistency * 0.3 + referential * 0.2;
  let reasoning = generateCertaintyReasoning(structural, consistency, referential, issues);
  return {
    score: Math.round(score * 100.0) / 100.0,
    factors: {
      structural: Math.round(structural * 100.0) / 100.0,
      consistency: Math.round(consistency * 100.0) / 100.0,
      referential: Math.round(referential * 100.0) / 100.0
    },
    reasoning: reasoning
  };
}

function validate(citation) {
  let structuralIssues = validateStructure(citation);
  let consistencyIssues = validateConsistency(citation);
  let referentialIssues = validateReferences(citation);
  let issues = structuralIssues.concat(consistencyIssues).concat(referentialIssues);
  let state = determineState(issues);
  let certainty = calculateCertainty(citation, issues);
  return {
    citation: citation,
    state: state,
    certainty: certainty,
    issues: issues,
    timestamp: new Date()
  };
}

function validateBatch(citations) {
  return citations.map(validate);
}

export {
  requiredFields,
  hasField,
  validateStructure,
  isValidDateFormat,
  extractYear,
  validateConsistency,
  isValidDOI,
  isValidISBN,
  validateReferences,
  determineState,
  calculateCertainty,
  generateCertaintyReasoning,
  validate,
  validateBatch,
}
/* No side effect */
